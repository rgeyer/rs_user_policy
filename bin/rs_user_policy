#!/usr/bin/env ruby

# Copyright (c) 2012 Ryan J. Geyer
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

require 'trollop'
require 'right_api_client'
require 'logger'
require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib', 'rs_user_policy'))

opts = Trollop::options do
  banner = "Manages users across many different child accounts of a RightScale Enterprise Master Account"

  opt :rs_email, "You RightScale User Email Address", :type => :string, :required => true
  opt :rs_pass, "Your RightScale User Password", :type => :string, :required => true
  opt :rs_acct_num, "A RightScale Enterprise Master Account ID", :type => :string, :required => true
  opt :policy, "The path to a JSON file containing the role to permissions policy to enforce", :type => :string, :required => true
  opt :user_assignments, "The path to a JSON file containing email address => role pairs for user assignments", :type => :string
  opt :dry_run, "A flag indicating that no changes should be made, only the user_assignments.json should be evaluated (or created) and the audit_log.json produced"
end

log = Logger.new(STDOUT)
timestamp = Time::now.to_i
deleted_users = []
accounts = []

if opts[:dry_run]
  log.info("The dry_run option was selected, no action will be taken, but the user_assignments output and audit_log files will be written reflecting the actions which would have been taken")
end

user_assignments_output = "user_assignments-#{timestamp}.json"

audit_log = RsUserPolicy::AuditLog.new opts.merge(:timestamp => timestamp)

policy = nil
begin
  policy = RsUserPolicy::Policy::JsonPolicy.new(:filename => opts[:policy])
rescue Exception => e
  log.fatal("Unable to initialize policy from filename #{opts[:policy]}.  Error: #{e.message}")
  exit 1
end

user_assignments_options = opts[:user_assignments] ? { :filename => opts[:user_assignments] } : {}
user_assignments = RsUserPolicy::UserAssignments::JsonUserAssignments.new(user_assignments_options)
if user_assignments.length == 0
  log.warn("No user_assignments file was specified or the file could not be found.  All users will be treated as immutable and written to the user_assigments output file.")
end

user_collection = RsUserPolicy::UserCollection.new

client = RightApi::Client.new(:email => opts[:rs_email], :password => opts[:rs_pass], :account_id => opts[:rs_acct_num])
master_account = client.accounts(:id => opts[:rs_acct_num]).show()
user_collection.add_users(client.users.index)
user_collection.add_permissions(master_account.href, client.permissions.index)

accounts << {:client => client, :href => master_account.href, :name => master_account.name}

log.info("Operating on the Enterprise Master Account #{master_account.name}")

begin
  client.child_accounts.index.each do |child|
    child_client = RightApi::Client.new(:email => opts[:rs_email], :password => opts[:rs_pass], :account_id => RsUserPolicy::Utilities.id_from_href(child.href))
    accounts << {:client => child_client, :href => child.href, :name => child.name}

    user_collection.add_users(child_client.users.index)
    user_collection.add_permissions(child.href, child_client.permissions.index)
  end
rescue RightApi::Exceptions::ApiException => e
  if e.message =~ /Permission denied/
    log.warn("#{master_account.name} is not an Enterprise Master, or you do not have the enterprise_manager permission.  No child accounts will be operated on.")
  else
    raise e
  end
end

begin
  accounts.each do |account|
    child_client = account[:client]

    log.info("#{account[:name]} - #{account[:href]}")
    user_collection.users.each do |user|
      email = user.email
      user_role = user_assignments.get_roles(email)
      existing_permissions = user.get_api_permissions(account[:href])

      # Allow some different options about possibly prompting the user etc
      if user_role.include?('delete')
        # Note: This is an explicit delete across all master and child accounts
        # a user can also be effectively deleted if they have an empty list of
        # permissions for a particular account
        unless opts[:dry_run]
          log.debug("Deleting #{user.email} from #{account[:name]} by removing these permissions #{JSON.pretty_generate(existing_permissions)}")
          user.clear_permissions(account[:href], child_client)
          user_assignments.delete(user.email)
        end
        audit_log.add_entry(email, account[:name], 'deleted', 'deleted')
      else
        user_policy = policy.get_permissions(user_role, account[:href])
        removed,added = user.set_api_permissions(user_policy, account[:href], child_client, opts)
        changes = "-#{removed.values} +#{added.values}"
        audit_log.add_entry(email, account[:name], 'update_permissions', changes) unless removed.length + added.length == 0
      end
    end
  end
rescue RightApi::Exceptions::ApiException => e
  log.fatal("A RightScale API exception occurred - #{e}")
end

user_assignments.serialize(:filename => user_assignments_output)
audit_log.write_file